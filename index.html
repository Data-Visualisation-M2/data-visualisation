<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }
    div.tooltip {
      color: #222;
      background-color: #fff;
      padding: 0.1em;
      text-shadow: #f5f5f5 0 1 px 0;
      opacity: 0.9;
      position: absolute;
    }
  </style>
</head>

<body>
  <script>
    function showBarPlot(data, name) {        // Clear any existing bar plot
        d3.select("#bar-plot").remove();

        // Create a new SVG group for the bar plot
        var barPlotGroup = svg.append("g")
            .attr("id", "bar-plot")
            .attr("transform", "translate(" + (width - 200) + ", "+(height-100)+")");

        console.log("barPlotGroup dimensions:", barPlotGroup.node().getBBox());

        var barWidth = 30;

        // Create bars
        barPlotGroup.selectAll("rect")
            .data(data)
            .enter().append("rect")
            .attr("x", function(d, i) { return i * (barWidth + 5); })
            .attr("y", function(d) { return -d.value; }) // Invert the y-axis for better visualization
            .attr("width", barWidth)
            .attr("height", function(d) { return d.value; })
            .style("fill", "steelblue");

        // Add labels
        barPlotGroup.selectAll("text")
            .data(data)
            .enter().append("text")
            .attr("x", function(d, i) { return i * (barWidth + 5) + barWidth / 2; })
            .attr("y", function(d) { return -d.value - 5; }) // Offset the label above the bar
            .attr("text-anchor", "middle")
            .attr("class", "label")
            .text(function(d) { return d.value; });

        
        barPlotGroup.selectAll("text")
            .data(data)
            .enter().append("text")
            .attr("x", function(d, i) { return i * (barWidth + 5) + barWidth / 2; })
            .attr("y", function(d) { return 5; }) // Offset the label above the bar
            .attr("text-anchor", "middle")
            .attr("class", "label")
            .text(function(d) { return d.category; });


        barPlotGroup.append("text")
          .attr("x",(width/8))
          .attr("y",-50)
          .attr("text-anchor","middle")
          .style("font-size", "16px")
          .text("Données")
    }

    var width = 700,
      height = 580;
    
    var margin = { top: 20, right: 20, bottom: 20, left: 20 };

    var svg = d3
      .select("body")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var tooltip = d3
      .select("body")
      .append("div")
      .attr("class", "hidden tooltip");

    var color = d3.scaleQuantize()
    .range(["#edf8e9", "#bae4b3", "#74c476","#31a354","#006d2c"])
    
    // On rajoute un groupe englobant toute la visualisation pour plus tard
    var g = svg.append("g");

    var projection = d3
      .geoAlbersUsa()
      .translate([width / 2, height / 2])
      .scale([500]);

    var path = d3.geoPath().projection(projection);
/*
    d3.json("data.json").then(function(data){
      d3.json("velovPosition.json").then(function (position) {
        // Set up SVG container with margins
        var margin = { top: 20, right: 20, bottom: 20, left: 20 };
        var width = 500 - margin.left - margin.right;
        var height = 500 - margin.top - margin.bottom; // Define scales

        for(var i = 0; i<data['features'][i].length;i++){
          var dataStationID = data['features'][i]['properties'].number;
          for(var j = 0;j<position.features.length;j++){
            var jsonStationID = position.features[i].properties.idstation;
            if(dataStationID === jsonStationID){
              /*let availabilities = data['values'][j]['main_stands']['availabilities'];
              let capacity = data['values'][j]['main_stands']['capacity'];
              position.features[i].properties.value = 
                (
                  availabilities.bikes+
                  availabilities.electricalBikes+
                  availabilities.electricalInternalBatteryBikes+
                  availabilities.electricalRemovableBatteryBikes+
                  availabilities.mechanicalBikes)
                /capacity;
              availabilities['capacities'] = capacity
              position.features[i].properties.data = availabilities;
              if(data.properties[j].status !== "OPEN"){
                position.features[i].properties.data["status"] = data.properties[j].status;
              }*//*
              console.log("Trouvé!")
            }
          }
        }

        var xScale = d3
          .scaleLinear()
          .domain([
            d3.min(position.features, (d) => d.geometry.coordinates[0]),
            d3.max(position.features, (d) => d.geometry.coordinates[0])
          ])
          .range([0, width]);

        var yScale = d3
          .scaleLinear()
          .domain([
            d3.min(position.features, (d) => d.geometry.coordinates[1]),
            d3.max(position.features, (d) => d.geometry.coordinates[1])
          ])
          .range([height, 0]);
        // Plot the points with initial translation
        var points = svg
          .selectAll("circle")
          .data(position.features)
          .enter()
          .append("circle")
          .attr("cx", function (d) {
            return xScale(d.geometry.coordinates[0]) + margin.left; // Add margin.left to move points
          })
          .attr("cy", function (d) {
            return yScale(d.geometry.coordinates[1]) + margin.top; // Add margin.top to move points
          })
          .attr("r", 5) // Initial radius
          //.style("fill", "blue")
          .style("fill",d=>{
            if(d.properties.data){
              console.log(d.properties.data);
              let status = d.properties.data.status;
              let value = d.properties.value;
              if(status){
                return "black";
              }else if(value){
                return color(value);
              }else{
                return "blue"
              }
            }else{
              return "black"
            }
          })
          //Our new hover effects
          .on("mousemove", function (d, i) {
            var mousePosition = [d.x, d.y];
            var htmlText = i.properties.nom + "(" + i.properties.commune + ")";
            if(i.properties.data){
              let availabilities = i.properties.data;
              htmlText += "<br><ul>"+
                "<li>Capacité maximale : "+availabilities.capacities+"</li>"+
                "<li>Vélos electriques : "+availabilities.electricalBikes+"</li>"+
                "<li>Vélos electriques (batterie interne) : "+availabilities.electricalInternalBatteryBikes+"</li>"+
                "<li>Vélos electriques (batterie externe) : "+availabilities.electricalRemovableBatteryBikes+"</li>"+
                "<li>Vélos méchaniques : "+availabilities.mechanicalBikes+"</li>"+
                "<li>Stands : "+availabilities.stands+"</li>"+
                "</ul>"
            }else{
              htmlText += "<br/>Aucune pour le jour en cours!"
            }
            tooltip
              .classed("hidden", false)
              .attr(
                "style",
                "left:" +
                  (mousePosition[0] + 1) +
                  "px; top:" +
                  (mousePosition[1] - 35) +
                  "px"
              )
              .html(htmlText);
          })
          .on("mouseout", function (d, i) {
            //d3.select(this).transition().duration("50").attr("opacity", "1");
            tooltip.classed("hidden", true);
          });

        // Add zoom functionality
        var zoom = d3
          .zoom()
          .scaleExtent([1, 10])
          .on("zoom", function (event) {
            // Update point radius based on zoom scale
            points.attr("r", 5 / event.transform.k); // Adjust 5 as needed
            svg.attr("transform", event.transform);
            svg.attr("width", 500).attr("height", 500);
          });

        svg.call(zoom);
      });
    })*/

  var projection = d3.geoMercator().translate([700/2,580/2])
  var path = d3.geoPath().projection(projection);
  d3.json("lyon.json").then((geoJSON)=>{
    /*
    // Set up SVG container
    var width = 500;
    var height = 500;

    var svg = d3.select("#svg-container")
        .attr("width", width)
        .attr("height", height);

    // Create a GeoJSON path generator
    var path = d3.geoPath();

    // Calculate the bounding box of the entire GeoJSON feature collection
    var bounds = d3.geoBounds(geoJSON);

    // Define initial scales based on bounding box
    var xScale = d3.scaleLinear()
        .domain([bounds[0][0], bounds[1][0]])
        .range([0, width]);

    var yScale = d3.scaleLinear()
        .domain([bounds[0][1], bounds[1][1]])
        .range([height, 0]);

    // Create a zoom behavior with minimum and maximum scales
    var zoom = d3.zoom()
        .scaleExtent([1, 10]) // Adjust as needed
        .on("zoom", function(event) {
            svg.attr("transform", event.transform);
        });

    // Apply zoom to the SVG container
    svg.call(zoom);

    // Draw GeoJSON features
    svg.selectAll("path")
        .data(geoJSON.features)
        .enter().append("path")
        .attr("d", path)
        .style("fill", "steelblue")
        .style("stroke", "grey");
    
    // Set an initial zoom level
    var initialZoom = d3.zoomIdentity.scale(2); // You can adjust the initial zoom level
    svg.call(zoom.transform, initialZoom);
    */
    d3.json("data.json").then(function(data) {
      // Set up SVG container with margins
      var margin = { top: 20, right: 20, bottom: 20, left: 20 };
      var width = 500 - margin.left - margin.right;
      var height = 500 - margin.top - margin.bottom;

      for(var i = 0;i<data.features.length;i++){
        let currentData = data.features[i].properties;
        let availabilities = currentData.main_stands.availabilities;
        let capacity = currentData.total_stands.capacity;
        currentData.value = 
        (
          availabilities.bikes+
          availabilities.electricalBikes+
          availabilities.electricalInternalBatteryBikes+
          availabilities.electricalRemovableBatteryBikes+
          availabilities.mechanicalBikes
        )
        /capacity;
        availabilities['capacities'] = capacity
        currentData.data = availabilities;
        if(data.features[i].status === "OPEN" || data.features[i].status === "CLOSED"){
          currentData.data["status"] = data.features[i].status;
        }
        if(!currentData.value){
          currentData.value = 0.000001;
        }
      }

      // Define scales
      var xScale = d3.scaleLinear()
          .domain([d3.min(data.features, d => d.geometry.coordinates[0]), d3.max(data.features, d => d.geometry.coordinates[0])])
          .range([0, width]);

      var yScale = d3.scaleLinear()
          .domain([d3.min(data.features, d => d.geometry.coordinates[1]), d3.max(data.features, d => d.geometry.coordinates[1])])
          .range([height, 0]);

      // Plot the points with initial translation
      var points = svg.selectAll("circle")
          .data(data.features)
          .enter()
          .append("circle")
          .attr("cx", function(d) {
              return xScale(d.geometry.coordinates[0]) + margin.left; // Add margin.left to move points
          })
          .attr("cy", function(d) {
              return yScale(d.geometry.coordinates[1]) + margin.top; // Add margin.top to move points
          })
          .attr("r", 5) // Initial radius
          .style("fill", (d)=>{
            //return "blue"
            if(d.properties.data){
              let status = d.properties.data.status;
              let value = d.properties.value;
              if(status){
                return "black";
              }else if(value){
                return color(value);
              }else{
                return "blue"
              }
            }else{
              return "black"
            }
          })
          //Our new hover effects
          .on("mousemove", function (event, station) {
            var mousePosition = [event.x, event.y];
            var htmlText = station.properties.name + "(" + station.properties.commune + ")";
            if(station.properties.data){
              let availabilities = station.properties.data;
              htmlText += "<br><ul>"+
                "<li>Capacité maximale : "+availabilities.capacities+"</li>"+
                "<li>Vélos electriques : "+availabilities.electricalBikes+"</li>"+
                "<li>Vélos electriques (batterie interne) : "+availabilities.electricalInternalBatteryBikes+"</li>"+
                "<li>Vélos electriques (batterie externe) : "+availabilities.electricalRemovableBatteryBikes+"</li>"+
                "<li>Vélos méchaniques : "+availabilities.mechanicalBikes+"</li>"+
                "<li>Stands : "+availabilities.stands+"</li>"+
                "</ul>"
            }else{
              htmlText += "<br/>Aucune pour le jour en cours!"
            }
            tooltip
              .classed("hidden", false)
              .attr(
                "style",
                "left:" +
                  (mousePosition[0] + 1) +
                  "px; top:" +
                  (mousePosition[1] - 35) +
                  "px"
              )
              .html(htmlText);
          })
          .on("mouseout", function (event, station) {
            //d3.select(this).transition().duration("50").attr("opacity", "1");
            tooltip.classed("hidden", true);
          })
          .on("click",(_,station)=>{
            let availabilities = station.properties.data;
            data = [
              {category:'Electriques',value:availabilities.electricalBikes*10 || 0},
              {category:'Electriques (batterie interne)',value:availabilities.electricalInternalBatteryBikes*10 || 0},
              {category:'Electriques (batterie externe)',value:availabilities.electricalRemovableBatteryBikes*10 || 0},
              {category:'Méchaniques',value:availabilities.mechanicalBikes*10 || 0},
            ]
            showBarPlot(data,station.properties.name);
          })
          ;

      // Add zoom functionality
      var zoom = d3.zoom()
          .scaleExtent([1, 10])
          .on("zoom", function(event) {
              // Update point radius based on zoom scale
              points.attr("r", 5 / event.transform.k); // Adjust 5 as needed
              svg.attr("transform", event.transform);
          });

      svg.call(zoom);
    });
  });
  </script>
</body>
